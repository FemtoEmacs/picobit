#lang racket

(provide (all-defined-out))
(require racket/mpair)
(require "utilities.rkt")

;; Environment representation.

(define-struct var
  (id ; identifier?
   global?
   (refs #:mutable)
   (sets #:mutable)
   (defs #:mutable)
   (needed? #:mutable)
   primitive)
  #:transparent)

(define-struct primitive
  (nargs
   (constant-folder #:mutable) ; added post-creation
   (eta-expansion   #:mutable) ; for higher-order uses
   unspecified-result?)
  #:transparent)

(define/contract (make-primitive-var id prim)
  (identifier? primitive? . -> . var?)
  (make-var id #t '() '() '() #f prim))
(define/contract (make-global-var    id def)
  (identifier? any/c      . -> . var?)
  (make-var id #t '() '() (list def) #f #f))

(define (var-bare-id v) (syntax->datum (var-id v))) ; for code-generation

;; WARNING: currently is only symbol equality, so is defeater by shadowing.
;; Once we plug in Racket's expander, we'll be able to do better.
(define (var=? x y) (eq? (syntax->datum x) (syntax->datum y)))
;; TODO use free-identifier=?


(define allow-forward-references? (make-parameter #t))

(define/contract (env-lookup env id) ((mlistof var?) identifier? . -> . var?)
  (or (for/first ([b (in-mlist env)]
                  #:when (var=? (var-id b) id))
        b)
      ;; We didn't find it. If reasonable to do so, add it to the env.
      ;; This makes it possible to have forward references at the top level.
      (let ([x (make-var id #t '() '() '() #f #f)])
        (unless (allow-forward-references?)
          (compiler-error "variable referenced before its definition:" id))
        (mappend! env (mlist x))
        x)))

(define/contract (env-extend env ids def)
  ((mlistof var?) (listof identifier?) any/c . -> . (mlistof var?))
  (mappend (list->mlist
            (map (lambda (id)
                   (make-var id #f '() '() (list def) #f #f))
                 ids))
           env))


;; extra code environment : list of AST nodes
;; To hold code generated by the compiler that must be compiled along with the
;; rest of the program (e.g. primitive eta-expansions).
;; All this code needs to be generated before compilation begins, and will be
;; merged with the rest of the program after parsing.
(define extra-code-env '())
(define (add-extra-code c) (set! extra-code-env (cons c extra-code-env)))
